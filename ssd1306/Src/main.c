/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "stm32_f429xx.h"

#include "sysTick.h"

#include "ssd1306.h"

#define SA SSD1306_ADDR

#define PLL_M  4
#define PLL_N  64
#define PLL_P  0

uint32_t sysTickCount = 0;

void config_clock(void)
{
	//1)trurn on the HSE
	RCC->CR |= RCC_CR_HSEON;
	//wait for HSE ready
	while(!(RCC->CR & RCC_CR_HSERDY));
	//2)set the power enable clock and voltage regulator
	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
	PWR->CR |= PWR_CR_VOS;

	//3)config the flash prefetch and latancy related settings
	FLASH->ACR = FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_PRFTEN |FLASH_ACR_LATENCY_5WS;
	//4)config the prescalars hclk, pclk1, pclk2
	//AHB PR  64 / 1
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
	//APB1 PR 64 / 8 = 8M
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV8;
	//APB2 PR 64 / 8 = 8Mz
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV8;
	//5) config the main pll
	//sys_pll_clk = 8/4 = 2 * 64 = 128 / 2 = 64 pll_ck is selected as sys_clk
	RCC->PLLCFGR = (PLL_M << 0) | (PLL_N << 6) | (PLL_P << 16) | (RCC_PLLCFGR_PLLSRC_HSE);
    //6)enable PLL and wait for it to become ready
	RCC->CR |= RCC_CR_PLLON;
	while(!(RCC->CR & RCC_CR_PLLRDY));
	//7) select the clock source and wait for it to be set
	RCC->CFGR |= RCC_CFGR_SW_PLL;
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

void i2c_gpio_init(void)
{
	//enable clock for GPIOB
	RCC->AHB1ENR |= (1 << 1);

	GPIOB->OTYPER |= (1 << 6);
	GPIOB->OTYPER |= (1 << 7);
	//bydefault push pull enabled
	GPIOB->PUPDR |= (1 << 12);//internally pulling up the PB6
	GPIOB->PUPDR |= (1 << 14);//internally pulling up the PB7
	//enable alternate function for PB6
	GPIOB->MODER |= (2 << 12);
	//enable alternate function for PB7
	GPIOB->MODER |= (2 << 14);
	//setting PB6 as SCL
	GPIOB->AFR[0] |= (4 << 24);
	//setting PB7 as SDA
	GPIOB->AFR[0] |= (4 << 28);
}

void i2c_init(void)
{
	//enable clock for I2C peripheral
	RCC->APB1ENR |= (1 << 21);
	//to generate a 100KHz SCL frequency
	//APB1 Clock(PCL1) = 25Mhz
	//1)config mode in CCR reg (15th bit)
	//2)program FREQ field of CR2 with the value of PCLK1
	//3)calculate and progaram CCR value in CCR field of CCR reg

	//if DUTY = 0 (for standared mode)-------------------------------
	//Thigh(SCL) = CCR * Tpclk1
	//Tlow(SCL) = CCR * Tpclk1

	//for 100Khz 5us is Thigh(SCL)
	//for 16Mhz clk the time value is 62.5ns
	//then CCR = 80;
	//FREQ = 16,CCR = 80 for scl = 100Khz

	//if DUTY = 1:(to reach 400Khz)----------------------------------
	//Thigh(SCL) = 9 * CCR * Tpclk1
	//Tlow(SCL) = 16 * CCR * Tpclk1

	//ack cntrl bit
	//I2C1->CR1 |= handle->config.I2C_Ack_Ctrl << 10;
	I2C1->CR1 |= 1 << 10;
	//config FREQ field of CR2
	I2C1->CR2 = 8 & 0x3F;
	//only if the device is used as slave
	//need to keep that 14th bit high
	I2C1->OAR1 |= (SA << 1) | (1 << 14);
	I2C1->CCR = 0x28;
	I2C1->TRISE = (8000000 / 1000000U) + 1;

	I2C1->CR1 |= (1 << 0);
}

void i2c_master_send_data(uint8_t* tx_buffer,uint32_t len)
{
	uint8_t slave_address = SA;
	uint32_t dummy;
	//1)generate start condition
	I2C1->CR1 |= (1 << 8);
	//2)confirm that start generation is completed by checking the SB flag in SR1
		//until SB is cleared SCL will be streched (pulled low)
	while(!(I2C1->SR1 & (1 << 0)));
	//3)send the address of the slave with read/write bit set to w(0)
	slave_address = slave_address << 1;
	slave_address &= ~(1); //slave add + r/w bit
	I2C1->DR = slave_address;
	//4) confirm that address phase is completed by checking the ADDR flag in SR1
	while(!(I2C1->SR1 & (1 << 1)));
	//5) clear the ADDR flag according to its SW sequence
	//note: until ADDR is cleared SCL will be stretched
	dummy = I2C1->SR1;
	dummy = I2C1->SR2;
	(void)dummy;
	//6) send data until length becomes 0
	while(len > 0)
	{
		while(!(I2C1->SR1 & (1 << 7))); //todo: need to check tx completed bit

		I2C1->DR = *tx_buffer;
		tx_buffer++;
		len--;
	}
	//7)when len becomes 0 wait for the TXE=1 and BTF=1 before generating the STOP condition
	// note: TXE=1,BTF=1, means that both SR and DR are empty and next transmission should begin
	// when BTF=1 SCL will be stretched (pulled to LOW)
	while(!(I2C1->SR1 & (1 << 7)));
	while(!(I2C1->SR1 & (1 << 2)));

	//8) genetare stop condition and master need not to wait for the completion of stop condition
	//note: generating STOP, automatically clears the BTF
	I2C1->CR1 |= (1 << 9);
}

void init_sytick(void)
{
	SYS_TICK->CTRL = (1 << 1);

	SYS_TICK->RLV = 8000U - 1U;
	SYS_TICK->CV = 0;


	SYS_TICK->CTRL |= (1 << 0);
}

void SysTick_Handler(void)
{
	sysTickCount++;
}

uint32_t xGetTickCount(void)
{
	return sysTickCount;
}

void delay(uint32_t del)
{
	uint32_t tickCnt = xGetTickCount();

	while((xGetTickCount() - tickCnt) < del);
}

int main(void)
{
	char str[50] = {0};
	int secCount = 0;
	config_clock();
	i2c_gpio_init();
	i2c_init();
	init_sytick();

	SSD1306_Init(SSD1306_ADDR);



    /* Loop forever */
	for(;;)
	{
		sprintf(str,"SEC :%d",secCount++);
		SSD1306_SetPosition (5, 1);
		SSD1306_DrawString (str);
		SSD1306_UpdateScreen(SSD1306_ADDR);
		delay(1000);
	}
}
