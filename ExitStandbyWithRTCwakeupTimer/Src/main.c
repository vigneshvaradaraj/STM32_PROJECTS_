/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "rtc.h"
#include "stm32_f429xx.h"
#include "iwdg.h"
#include "wwdg.h"
#include "led.h"
#include "gpio_exti.h"
#include "standby_mode.h"

#define BUFF_LEN   20

#if 0
static void display_rtc_calander(void);
#endif

void led_blink_forever(void);
static void wait_btn_press(void);
uint8_t time_buff[BUFF_LEN] = {0};
uint8_t date_buff[BUFF_LEN] = {0};

int hr = 0,mnt = 0,sec = 0, mon = 0, day = 0, year = 0;
uint8_t g_btn_press = 0;

/*
 Sys clock Cfg
 System clock source = HSE
 SYSCLK				 = 8Mhz
 HCLK				 = 2Mhz
 AHB Prescaler 		 = 4
 APB1 Prescaler 	 = 1
 APB2 Prescaler 	 = 1
 HSE				 = 8Mhz
 Main regulator Scale 1
 Flash latancy  = 0
*/
void clock_config(void)
{
	/*Enable HSE oscillator*/
	RCC->CR |= RCC_CR_HSEBYP;
	RCC->CR |= RCC_CR_HSEON;

	/*Wait till HSERDY goes low*/
	while((RCC->CR & RCC_CR_HSERDY) == (RCC_CR_HSERDY));

	/*Set FLASH latancy*/
	FLASH->ACR &= ~FLASH_ACR_LATENCY;
	FLASH->ACR |= FLASH_ACR_LATENCY_0WS;

	/*Sysclk activation on the main PLL*/
	RCC->CFGR &= ~RCC_CFGR_HPRE;
	RCC->CFGR |= RCC_CFGR_HPRE_DIV4;

	/*Set clock source*/
	RCC->CFGR &= ~RCC_CFGR_SW;
	RCC->CFGR |= RCC_CFGR_SW_HSE;

	/*Wait till HSE is used as system clock*/
	while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS);

	/*Set APB1 Prescaler*/
	RCC->CFGR &= ~RCC_CFGR_PPRE1;
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1;

	/*Set APB2 Prescaler*/
	RCC->CFGR &= ~RCC_CFGR_PPRE2;
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
}

/*Press the blue push botton to enter stand by mode*/
/*PA0 is wakeup pin and itis active low*/
/*connect a jumper wire from PA0 to gnd in normal mode*/
/*pull out jumper wire and connect to 3.3v to cause a change in logic which will in turn trigger the wakeup*/

int main(void)
{
    /* Loop forever
	rtc_init();
	rtc_alarm_init();
	rtc_timestamp_init();
	rtc_tamper_detect_init();
	*/

	//clock_config();
	gpio_interrupt_init();
	led_init();
	rtc_wkup_timer_init();
	/*Check if system resumed and check source */
	if((PWR->CSR & PWR_CSR_SBF) != PWR_CSR_SBF)
	{
		/*Run after normal reset*/
		wait_btn_press();
		/*system going to standby mode*/
		/*Enter standby with RTC wakeup timer enabled*/
		enter_standby_mode_rtc_wkup();
	}
	else
	{
		/*Clear standby flag*/
		PWR->CR |= PWR_CR_CSBF;

		/*Reset the internal wakeup flag*/
		RTC->ISR &= ~RTC_ISR_WUTF;

		/*System back from standby mode*/
	}
	for(;;)
	{

	}
}

static void wait_btn_press(void)
{
	while(g_btn_press == 0)
	{
		GPIOA->ODR ^= (1U << 5U);
		for(int i = 0;i < 90000;i++);
	}
}

#if 0
static void display_rtc_calander(void)
{
	hr = rtc_convert_bcd2bin(rtc_time_get_hour());
	mnt = rtc_convert_bcd2bin(rtc_time_get_minute());
	sec = rtc_convert_bcd2bin(rtc_time_get_second());

	mon = rtc_convert_bcd2bin(rtc_date_get_month());
	day = rtc_convert_bcd2bin(rtc_date_get_day());
	year = rtc_convert_bcd2bin(rtc_date_get_year());
}
#endif

static void alarm_callback(void)
{
	(void)0;
}
void RTC_Alarm_IRQHandler(void)
{
	/*Get alarm interrupt source enable status*/
	if((RTC->CR & CR_ALRAIE) != 0)
	{
		/*Get the pending status of the Alarm interrupt*/
		if((RTC->ISR & ISR_ALRAF) != 0)
		{
			alarm_callback();
			/*Clear the Alarm interrupt pending bit*/
			RTC->ISR &= ~ISR_INIT;
		}
	}
	/*Clear the EXIT's flag for RTC Alarm*/
	EXTI->PR |= (1U << 17U);
}

void timestamp_event_callback(void)
{
	(void)0;
}

/*Tamper pin : PC13*/
/*Press push button to trigger tamper detection*/
void tamper_callback(void)
{
	/*Deactivate the tamper*/
	/*Disable tamper detection*/
	RTC->TAFCR &= ~RTC_TAFCR_TAMP1E;
	(void)0;
}
#ifdef TIMESTAMP
void TAMP_STAMP_IRQHandler(void)
{
	/*Get timesatmp interupt source enable status*/
	if((RTC->CR & CR_TSIE) != 0)
	{
		/*Get the pending status of the timesatmp interrupt*/
		if((RTC->ISR & ISR_TSF) != 0)
		{
			timestamp_event_callback();
			/*Clear the timesatmp interrupt pending bit*/
			RTC->ISR &= ~ISR_TSF;
		}
	}
	/*Clear the EXIT's flag for RTC timestamp*/
	EXTI->PR |= (1U << 21U);
}
#else
void TAMP_STAMP_IRQHandler(void)
{
	/*Get tamper interrupt source enable status*/
	if((RTC->TAFCR & RTC_TAFCR_TAMPIE) == RTC_TAFCR_TAMPIE)
	{
		/*Get the pending status of the tamper interrupt*/
		if((RTC->ISR & RTC_ISR_TAMP1F) == RTC_ISR_TAMP1F)
		{
			tamper_callback();

			/*Clear Tamper Interrupt pending bit*/
			RTC->ISR |= ~RTC_ISR_TAMP1F;
		}
	}
	/*Clear the EXIT's flag for RTC tamper*/
	EXTI->PR |= (1U << 21U);
}
#endif

static void btn_callback(void)
{
	/*button pressed*/
	g_btn_press = 1;
}
void EXTI15_10_IRQHandler(void)
{
	if((EXTI->PR & EXTI_IMR_IM13) == EXTI_IMR_IM13)
	{
		EXTI->PR = EXTI_IMR_IM13;
		btn_callback();
	}
}


